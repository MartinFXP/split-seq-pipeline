#!/usr/bin/env python

# TODO:
# 1. argparse to parse arguments
#    Which arguments should there be???
# should we use snakemake?

# Arguments:
# - fastq1 (read1 - actual sequencing read)
# - fastq2 (read2 - header)
# - output_dir

# algorithm steps:
# 1. convert fastq to unaligned bam
# 2. copy header
# 3. trim read2 to UMI-BC3-BC2-BC1
# 4. 

import argparse
from split_seq import tools, process, processv2, analysis
import datetime

parser = argparse.ArgumentParser()

parser.add_argument('mode', help="""Mode: one of "all", "preproc", "star", or "postproc".
"all" runs the entire pipeline.
"preproc" or "preprocess" runs all the steps prior to running STAR, producing a file called single_cells_barcoded_head.fastq in output_dir.
"star" assumes that output of preproc exists in output_dir, and tries to run the STAR alignment, producing a file called single_cells_barcoded_headAligned.out.sam.
"postproc" assumes that the output of star exists in  output_dir.
""")
parser.add_argument('--fq1', help='fastq1 - mRNA reads')
parser.add_argument('--fq2', help='fastq2 - reads contain UMI and barcodes')
parser.add_argument('--output_dir', help='output dir')
parser.add_argument('--chemistry', default='v1', help='Using v1 or v2 chemistry')
parser.add_argument('--genome_dir', default='./', help='path containing reference genome')
# TODO: this is currently unused
#parser.add_argument('--star_path', default='./', help='path containing STAR')
parser.add_argument('--genome', nargs='*', help='name(s) of genome(s)/species')
parser.add_argument('--genes', nargs='*', help='GTF file(s) with gene annotations')
parser.add_argument('--fasta', nargs='*', help='GTF file(s) with gene annotations')
parser.add_argument('--nthreads', default='4', help='number of threads to use')

args = parser.parse_args()

print(args)
print(args.mode)
print(args.fq1)
print(args.fq2)
print(args.output_dir)
print(args.chemistry)
print(args.genome_dir)

mode = args.mode.lower()
if mode == 'mkref':

    # Generate genome
    tools.make_combined_genome(args.genome, args.fasta, args.output_dir)
    
    # Make a combine annotation from GTF
    tools.make_gtf_annotations(args.genome, args.genes, args.output_dir)
    
    # Index genome with star
    tools.generate_STAR_index(args.output_dir, args.nthreads)

if mode == 'all':
    # Add barcode and UMI to header of read1 fastq
    print(datetime.datetime.now(),'Correcting barcodes...')
    tools.preprocess_fastq(args.fq1, args.fq2, args.output_dir, args.chemistry)

    # Align with STAR
    tools.run_star(args.genome_dir, args.output_dir, args.nthreads)

    print(datetime.datetime.now(),'Sorting aligned bamfile...')
    # Sort the output samfile
    tools.sort_sam(args.output_dir, args.nthreads)

    print(datetime.datetime.now(),'Getting molecular info...')
    # Get molecular information for each UMI
    processv2.molecule_info(args.genome_dir, args.output_dir, args.nthreads)

    print(datetime.datetime.now(),'Generating digital gene expression matrix...') 
    analysis.generate_dge_report(args.output_dir,args.genome_dir,args.chemistry)

    print(datetime.datetime.now(),'Finished successfully')

if mode == 'preproc' or mode == 'preprocess' or mode == 'preprocessing':
    tools.preprocess_fastq(args.fq1, args.fq2, args.output_dir, args.chemistry)
if mode == 'star':
    tools.run_star(args.genome_dir, args.output_dir)
if mode == 'postproc' or mode == 'postprocess' or mode == 'postprocessing':
    tools.sort_sam(args.output_dir, args.nthreads)
if mode == 'molinfo':
    #process.molecule_info(args.gtf_file, args.output_dir, args.nthreads)
    processv2.molecule_info(args.genome_dir, args.output_dir, args.nthreads)
if mode=='dge':
    analysis.generate_dge_report(args.output_dir,args.genome_dir,args.chemistry)
